
# coding: utf-8

# @file
# @brief Python functions to build interface for mathematica equations. C interface is defined here.
# # Script to wrap up Mathematica equations as a C library
# 
# 19-02-2018 LT
# To be run after `concerted_rots_generic.nb`

# In[6]:

from datetime import datetime


# ## Global definitions: function arguments

# In[7]:

Timestamp="//generated by Precompiler.ipynb on "+str(datetime.now())
args_impl_B=["struct cr_input_data bb"]
args_impl_A=["gsl_vector *T","const struct cr_input_data bb"]
args_expl  =["struct expl_data cr_in"]

hl_idx=["1","2","3","4","5","6","7"]
ll_idx=["12","13","23","14","24","34","33"]


# ### Filenames for C source

# In[8]:

header_name="CR_precomp.h"
src_name="CR_precomp.c"


# In[9]:

eqn_fname="CR_T7.c"
der_fname="CR_DerT7.c"
jac_fname="CR_JacT7.c"


# ## C Header

# In[10]:

def write_prototypes(fout,ret_type, func_name, func_args=[],comment="",idx_list=[]):
    """
    @brief write prototypes for functions 
    """
    if(comment!=""):
        fout.write(comment+"\n")
    if(len(idx_list)==0):
        str=ret_type+" "+func_name+" "+"("
        for a in func_args[:-1]:
            str+=a+","
        str+=func_args[-1]+");"
        fout.write(str+"\n")
    else:
        for idx in idx_list:
            str=ret_type+" "+func_name+idx+" "+"("
            for a in func_args[:-1]:
                str+=a+","
            str+=func_args[-1]+");"
            fout.write(str+"\n")

def write_prototypes_array(fout, ret_type, array_name, prototypes_name, func_args=[], comment="", idx_list=[], declaration=True):
    """
    @brief write prototype for functions working with arrays
    """
    if(comment!=""):
        fout.write(comment+"\n")
    str=ret_type+" (*"+array_name+"[%i]"%(len(idx_list))+")("
    for a in func_args[:-1]:
        str+=a+","
    str+=func_args[-1]+")"
    if(declaration):
        str+=";"
    else:
        str+=" = {"
        for idx in idx_list[:-1]:
            str+=prototypes_name+idx+", "
        str+=prototypes_name+idx_list[-1]+"};"
    fout.write(str+"\n")


# In[11]:

#@brief First portion of header CR_precomp.h
# Defines data structures used by all functions
HDR_1="""
#ifndef __conc_rot_precomputed
#define __conc_rot_precomputed
/**
 * @file
 * @brief Header file for interfacing with intenal concerted rotation functions
 */

#include <gsl/gsl_vector.h>
#include <gsl/gsl_matrix.h>
#include <gsl/gsl_linalg.h>
#include "../lib/messages.h"
/** @brief EPSIL_DET. */
#define EPSIL_DET (0.0000001)

/**
 * @brief Concerted rotation move state data
 *
 * Structure contain all data nesessary for representation of peptide backbone in space of concerted rotation.
 */
typedef struct cr_input_data {
    gsl_vector *dihed_angles;   /**< Vector of dihedral angles with length \\f$(numberOfResidues*2)+1\\f$. */
    gsl_vector *bend_angles;    /**< Vector of bending angles with length \\f$(numberOfResidues*2)+1\\f$. */
    gsl_vector *r;              /**< Vector of displacements along z with length \\f$(numberOfResidues*2)+1\\f$. */
    gsl_vector *d;              /**< Vector of displacements orthogonal to z with length \\f$(numberOfResidues*2)+1\\f$. */
} cr_input_data;

/**
 * @brief Allocation of #cr_input_data structure
 */
void alloc_cr_input_data(cr_input_data *bb);

/**
 * @brief Free #cr_input_data structure
 */
void free_cr_input_data(cr_input_data *bb);

/**
 * @brief Copy one #cr_input_data structure to other
 */
void memcpy_cr_input_data(cr_input_data *bb_a, const cr_input_data *bb_b);

/**
 * @brief Print #cr_input_data in given stream
 */
void print_cr_input_data(const cr_input_data *bb, FILE *stream);

/**
 * @brief Print comparison between two #cr_input_data structures
 */
void compare_cr_input_data(const cr_input_data *bb_a, const cr_input_data *bb_b, FILE *stream);

/**
 * @brief Compare two #cr_input_data if structures are same return 0 otherwise 1
 */
int compare_bend_angles(const cr_input_data *bb_a, const cr_input_data *bb_b);

/**
 * @brief Internal representation of protein backbone for concerted rotation move
 */
struct expl_data{
    double c [7]; /**< cos(phi) and cos(psi) angles. */
    double s [7]; /**< sin(phi) and sin(psi) angles. */
    double ca[7]; /**< alpha = bending angles cos(alpha) and cos(alpha) angles. */
    double sa[7]; /**< alpha = bending angles sin(alpha) and sin(alpha) angles. */
    double d [7]; /**< Vector of displacements orthogonal to z. */
    double r [7]; /**< Vector of displacements along z. */
};
"""

FTR="#endif //__conc_rot_precomputed"


# In[12]:

#@brief write header file CR_precomp.h
with open(header_name,'w') as hdr_file:
    hdr_file.write(Timestamp+HDR_1)
    #--high level functions
    #----implicit arguments
    write_prototypes(hdr_file,"void","T7",args_impl_A)
    write_prototypes(hdr_file,"int","TmT7_t",args_impl_A,comment="//Tangent vectors",idx_list=hl_idx)
    write_prototypes_array(fout=hdr_file,
                           ret_type="int",
                           array_name="TmT",
                           prototypes_name="TmT7_t",
                           func_args=["gsl_vector *","const struct cr_input_data"],
                           comment="//Tangent vectors function array",
                           idx_list=hl_idx,
                           declaration=True)
    write_prototypes(hdr_file,"gsl_vector *","DT7_t",args_impl_B,comment="//Derivatives",idx_list=hl_idx)
    write_prototypes(hdr_file,"gsl_matrix *","jac_t",args_impl_B,comment="//Jacobians",idx_list=hl_idx)
    write_prototypes_array(fout=hdr_file,
                           ret_type="gsl_matrix *",
                           array_name="jac",
                           prototypes_name="jac_t",
                           func_args=["struct cr_input_data"],
                           comment="//Jacobians function array",
                           idx_list=hl_idx,
                           declaration=True)
    #----explicit arguments
    write_prototypes(hdr_file,"void","T7_explicit",["gsl_vector *T","struct expl_data cr_in"])
    write_prototypes(hdr_file,"int","TmT7_explicit_t",args_expl,comment="//Tangent vectors",idx_list=hl_idx)
    write_prototypes(hdr_file,"gsl_vector *","DT7_explicit_t",args_expl,comment="//Derivatives",idx_list=hl_idx)
    write_prototypes(hdr_file,"gsl_matrix *","jac_explicit_t",args_expl,comment="//Jacobians",idx_list=hl_idx)
    #------T7
    write_prototypes(hdr_file,"double","get_T7_",args_expl,comment="//ll T7 get",idx_list=ll_idx)
    #------Derivatives
    hdr_file.write("//Elements of T7 derivatives\n")
    el=("1","2","3","4","5","6")
    for i in range(1,8):
        write_prototypes(hdr_file,"double","get_DT7_t"+str(i)+"_",args_expl,idx_list=el)
    #------jacobians
    jac_el=[]
    for i in range(1,7):
        for j in range(1,7):
            jac_el.append(str(i)+str(j))
    hdr_file.write("//Elements of T7 derivatives\n")
    for i in range(1,8):
        write_prototypes(hdr_file,"double","get_jac_t"+str(i)+"_",args_expl,idx_list=jac_el)
    hdr_file.write(FTR)


# ## Source file for high level functions

# In[13]:

#---Functions with implicit arguments
def write_func_implicit(fout,ret_type,func_name,idx,func_args):
    """
     @brief write function definition (implicit arguments: angles instead of sines and cosines)
    """
    defn=ret_type+" "+func_name+str(idx)+" ("+func_args[0]
    for a in func_args[1:]:
        defn+=","+a
    defn+=")\n{"
    defn+="""
    int i;
    double r,theta,alpha,d;
    struct expl_data cr_data;
    for(i=0;i<7;i++)
    {
        r=gsl_vector_get(bb.r,i);
        theta=gsl_vector_get(bb.dihed_angles,i);
        alpha=gsl_vector_get(bb.bend_angles, i);

        cr_data.r[i] = r;
        cr_data.c[i] =cos(theta);
        cr_data.s[i] =sin(theta);
        cr_data.ca[i]=cos(alpha);
        cr_data.sa[i]=sin(alpha);
    }
    for(i=0;i<7;i++)
    {
        d=gsl_vector_get(bb.d,i);
        cr_data.d[i]=d;
    }"""
    if(ret_type=="void"):
        defn+="""
    %s;\n}\n"""%(func_name+"_explicit"+str(idx)+"(T,cr_data)")
    else:
        defn+="""
    return %s;\n}\n"""%(func_name+"_explicit"+str(idx)+"(cr_data)");
    fout.write(defn)

#---vectors and matrices with explicit arguments
def write_expl_T7(fout):
    """
     @brief write T7 constraint function (explicit arguments: sines and cosines)
    """
    fn="""
void T7_explicit (gsl_vector *T, struct expl_data cr_in)
{
    gsl_vector_set(T,0,get_T7_12(cr_in));
    gsl_vector_set(T,1,get_T7_13(cr_in));
    gsl_vector_set(T,2,get_T7_23(cr_in));
    gsl_vector_set(T,3,get_T7_14(cr_in));
    gsl_vector_set(T,4,get_T7_24(cr_in));
    gsl_vector_set(T,5,get_T7_34(cr_in));
}
    """
    fout.write(fn)

def write_expl_vects(fout,fname,args,idx):
    """
    @brief write vector functions (derivatives) (explicit arguments: sines and cosines)
    """
    defn="gsl_vector * "+fname+"_explicit_t"+str(idx)+" ("+args+")\n"
    defn+="{\n"
    defn+="\tgsl_vector *t=gsl_vector_alloc(6);\n"
    for i in range(6):
        defn+="\tgsl_vector_set(t,"+str(i)+","+"get_"+fname+"_t"+str(idx)+"_"+str(i+1)+"(cr_in));\n"
    defn+="\t return t;\n}\n"
    fout.write(defn)

def write_expl_matr(fout,fname,args,idx):
    """
     @brief write matrix functions (jacobians) (explicit arguments: sines and cosines)
    """
    defn="gsl_matrix * "+fname+"_explicit_t"+str(idx)+" ("+args+")\n"
    defn+="{\n"
    defn+="\tgsl_matrix *m=gsl_matrix_alloc(6,6);\n"
    for i in range(6):
        defn+="\t//-- \n"
        for j in range(6):
            defn+="\tgsl_matrix_set(m,"+str(i)+","+str(j)+","+"get_"+fname+"_t"+str(idx)+"_"+str(i+1)+str(j+1)+"(cr_in));\n"
    defn+="\treturn m;\n}\n"
    fout.write(defn)

#TmT7 tangent space
def write_TmT7(fout,I):
    """
    @brief Tangent vectors to the manifold, considering angle I to be free
    """
    s=""""""
    for j in range(I-1):
        s+="""
        gsl_vector_set(T,%d,gsl_vector_get(T,%d));"""%(j,j+1)
    s+="""
        gsl_vector_set(T,%d,-1);"""%(I-1)
    str_TmT7="int TmT7_t"+str(I)+"("+args_impl_A[0]+","+args_impl_A[1]+")\n{"
    str_TmT7+="""
    int i,error, sign;
    char err_string[1024];
    double r,theta,alpha,d;
    double x;
    struct expl_data cr_data;
    gsl_matrix *M;
    gsl_vector *V;
    gsl_permutation * p = gsl_permutation_alloc (6);
    for(i=0;i<7;i++)
    {
        r=gsl_vector_get(bb.r,i);
        theta=gsl_vector_get(bb.dihed_angles,i);
        alpha=gsl_vector_get(bb.bend_angles, i);

        cr_data.r[i] = r;
        cr_data.c[i] =cos(theta);
        cr_data.s[i] =sin(theta);
        cr_data.ca[i]=cos(alpha);
        cr_data.sa[i]=sin(alpha);
    }
    for(i=0;i<7;i++)
    {
        d=gsl_vector_get(bb.d,i);
        cr_data.d[i]=d;
    }"""
    str_TmT7+="""
    M=jac_explicit_t%d( cr_data );"""%(I)
    str_TmT7+="""
    V=DT7_explicit_t%d( cr_data );"""%(I)
    str_TmT7+="""
    error=gsl_linalg_LU_decomp(M,p,&sign);
    if(error !=GSL_SUCCESS) {
        gsl_vector_free(V);
        gsl_matrix_free(M);
        sprintf(err_string,"GSL failing with error %d\\n",error);
        failed(err_string);
    }
    x= gsl_linalg_LU_det(M,sign);
    if (fabs(x) < EPSIL_DET )
    {
        gsl_vector_free(V);
        gsl_matrix_free(M);
        gsl_permutation_free(p);
        return -1;
    }"""
    str_TmT7+="""else {
        gsl_vector_view  T_ = gsl_vector_subvector (T, 1, 6);
        error=gsl_linalg_LU_solve(M,p,V,&T_.vector);
        %s
        gsl_vector_free(V);
        gsl_matrix_free(M);
        gsl_vector_scale(T,-1.0);
        gsl_permutation_free(p);
        return error;
    }
}\n"""%(s)
    fout.write(str_TmT7)


# In[14]:

#@brief write CR_precomp.c
with open(src_name,'w') as src_file:
    src_file.write(Timestamp+"\n")
    src_file.write("""
/**
 * @file
 * @brief Source file for interfacing with intenal concerted rotation functions
 */

""")
    src_file.write("#include \""+header_name+"\"\n\n")
    src_file.write("#include <math.h>\n")
    write_prototypes_array(fout=src_file,
                           ret_type="int",
                           array_name="TmT",
                           prototypes_name="TmT7_t",
                           func_args=["gsl_vector *","const struct cr_input_data"],
                           comment="//Tangent vectors function array",
                           idx_list=hl_idx,
                           declaration=False)
    write_prototypes_array(fout=src_file,
                           ret_type="gsl_matrix *",
                           array_name="jac",
                           prototypes_name="jac_t",
                           func_args=["struct cr_input_data"],
                           comment="//Jacobians function array",
                           idx_list=hl_idx,
                           declaration=False)
    func1="""
/**
 *
 * @param[in]      *bb               #cr_input_data structure.
 *
 * @return \c void
 */
    void alloc_cr_input_data(cr_input_data *bb){
    bb->dihed_angles = gsl_vector_alloc(7);
    bb->bend_angles  = gsl_vector_alloc(7);
    bb->r            = gsl_vector_alloc(7);
    bb->d            = gsl_vector_alloc(7);
}

/**
 *
 * @param[in]      *bb               #cr_input_data structure.
 *
 * @return \c void
 */
void free_cr_input_data(cr_input_data *bb){
    gsl_vector_free( bb->dihed_angles );
    gsl_vector_free( bb->bend_angles  );
    gsl_vector_free( bb->d            );
    gsl_vector_free( bb->r            );
}

/**
 *
 * @param[in]      *bb_a             Copy to.
 * @param[in]      *bb_b             Copy from.
 *
 * @return \c void
 */
void memcpy_cr_input_data(cr_input_data *bb_a, const cr_input_data *bb_b){
    gsl_vector_memcpy ( bb_a->dihed_angles, bb_b->dihed_angles);
    gsl_vector_memcpy ( bb_a->bend_angles , bb_b->bend_angles );
    gsl_vector_memcpy ( bb_a->r           , bb_b->r           );
    gsl_vector_memcpy ( bb_a->d           , bb_b->d           );
}

/**
 *
 * @param[in]      *bb               cr_input_data for printing.
 * @param[out]     *stream           FILE stream to which data are printed.
 *
 * @return \c void
 */
void print_cr_input_data(const cr_input_data *bb, FILE *stream){
    for(int i=0; i<7; i++){
        fprintf(stream, "dihed_angles[%i] = %g\n", i, gsl_vector_get(bb->dihed_angles, i));
    }
    for(int i=0; i<7; i++){
        fprintf(stream, "bend_angles[%i] = %g\n", i, gsl_vector_get(bb->bend_angles, i));
    }
    for(int i=0; i<7; i++){
        fprintf(stream, "r[%i] = %g\n", i, gsl_vector_get(bb->r, i));
    }
    for(int i=0; i<7; i++){
        fprintf(stream, "d[%i] = %g\n", i, gsl_vector_get(bb->d, i));
    }
}

/**
 *
 * @param[in]      *bb_a             The first cr_input_data for comparison.
 * @param[in]      *bb_b             The second cr_input_data for comparison.
 * @param[out]     *stream           FILE stream to which compariosn is printed.
 *
 * @return \c void
 */
void compare_cr_input_data(const cr_input_data *bb_a, const cr_input_data *bb_b, FILE *stream){
    for(int i=0; i<7; i++){
        fprintf(stream, "dihed_angles[%i] = %g | %g\n", i, gsl_vector_get(bb_a->dihed_angles, i), gsl_vector_get(bb_b->dihed_angles, i));
    }
    for(int i=0; i<7; i++){
        fprintf(stream, "bend_angles[%i] = %g | %g\n", i, gsl_vector_get(bb_a->bend_angles, i), gsl_vector_get(bb_b->bend_angles, i));
    }
    for(int i=0; i<7; i++){
        fprintf(stream, "r[%i] = %g | %g\n", i, gsl_vector_get(bb_a->r, i), gsl_vector_get(bb_b->r, i));
    }
    for(int i=0; i<7; i++){
        fprintf(stream, "d[%i] = %g | %g\n", i, gsl_vector_get(bb_a->d, i), gsl_vector_get(bb_b->d, i));
    }
}

/**
 *
 * @param[in]      *bb_a             The first cr_input_data for comparison.
 * @param[in]      *bb_b             The second cr_input_data for comparison.
 *
 * @return \c void
 */
int compare_bend_angles(const cr_input_data *bb_a, const cr_input_data *bb_b){
    // return 0 if same otherwise 1
    for(int i=0; i<7; i++){
        if (gsl_vector_get(bb_a->bend_angles, i) != gsl_vector_get(bb_b->bend_angles, i)){
            return 1;
        }
    }
    return 0;
}
"""
    src_file.write(func1)
    write_func_implicit(src_file,"void","T7","",args_impl_A)
    for I in range(1,8):
        write_TmT7(src_file,I)
    for I in range(1,8):
        write_func_implicit(src_file,"gsl_vector *","DT7","_t"+str(I),args_impl_A[1:])
    for I in range(1,8):
        write_func_implicit(src_file,"gsl_matrix *","jac","_t"+str(I),args_impl_A[1:])
#explicit arguments
    write_expl_T7(src_file)
    for I in range(1,8):
        write_expl_vects(src_file,"DT7","struct expl_data cr_in",I)
    for I in range(1,8):
        write_expl_matr(src_file,"jac","struct expl_data cr_in",I)
    
    # write_func_expl_hl(src_file,"")


# ## Source files for get functions
# 
# This section produces three source files: one for T7 equations, one for their derivatives and the third for their jacobians.

# In[15]:

def write_expl_function(fout,ret_type, func_prefix, func_name, func_args=[]):
    """
    @brief write function taking explicit parameters around a mathematica equation
    """
    with open(func_name+".c", 'r') as f_in:
        equation=f_in.readline()
    ##
    defn=ret_type+" "+func_prefix+func_name+" ("+func_args[0]
    for a in func_args[1:]:
        defn+=","+a
    defn+=")\n{"
    fout.write(defn+"\n")
    for i in range(1,8):
        fout.write("\tdouble c"+ str(i)+" = cr_in.c ["+str(i-1)+"];\n")
        fout.write("\tdouble s"+ str(i)+" = cr_in.s ["+str(i-1)+"];\n")
        fout.write("\tdouble ca"+ str(i)+"= cr_in.ca["+str(i-1)+"];\n")
        fout.write("\tdouble sa"+ str(i)+"= cr_in.sa["+str(i-1)+"];\n")
        fout.write("\tdouble r"+ str(i)+" = cr_in.r ["+str(i-1)+"];\n")
        fout.write("\tdouble d"+ str(i)+" = cr_in.d ["+str(i-1)+"];\n")
    #for i in range(1,8):

    fout.write("\treturn "+equation+";\n}\n")


# In[16]:

#Write Equations
ll_idx=("12","13","23","14","24","34","33")
with open(eqn_fname,'w') as eqn_file:
    eqn_file.write(Timestamp+"\n")
    eqn_file.write("#include \""+header_name+"\"\n\n")
    for idx in ll_idx:
        fname="T7_"+idx
        write_expl_function(eqn_file,"double", "get_",fname,func_args=args_expl)
#Write Derivatives
with open(der_fname,'w') as der_file:
    der_file.write(Timestamp+"\n")
    der_file.write("#include \""+header_name+"\"\n\n")
    for i in range(1,8):
        for j in range(1,7):
            fname="DT7_t"+str(i)+"_"+str(j)
            write_expl_function(der_file,"double", "get_",fname,func_args=args_expl)
#Write Jacobians
with open(jac_fname,'w') as jac_file:
    jac_file.write(Timestamp+"\n")
    jac_file.write("#include \""+header_name+"\"\n\n")
    for i in range(1,8):
        for j in range(1,7):
            for k in range(1,7):
                fname="jac_t"+str(i)+"_"+str(j)+str(k)
                write_expl_function(jac_file,"double", "get_",fname,func_args=args_expl)


